<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>Redis基础 | 青青草原上的菠萝屋</title><meta name="author" content="ww"><meta name="copyright" content="ww"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="认识NoSQL什么是NoSQL NoSQL最常见的解释是”non-relational“， 很多人也说它是”Not Only SQL“ NoSQL仅仅是一个概念，泛指非关系型的数据库 区别于关系数据库，它们不保证关系数据的ACID特性 NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入 常见的NoSQL数据库有："><meta property="og:type" content="article"><meta property="og:title" content="Redis基础"><meta property="og:url" content="https://www.wweicloud.com/2023/03/13/Redis%E5%9F%BA%E7%A1%80/index.html"><meta property="og:site_name" content="青青草原上的菠萝屋"><meta property="og:description" content="认识NoSQL什么是NoSQL NoSQL最常见的解释是”non-relational“， 很多人也说它是”Not Only SQL“ NoSQL仅仅是一个概念，泛指非关系型的数据库 区别于关系数据库，它们不保证关系数据的ACID特性 NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入 常见的NoSQL数据库有："><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/wallhaven-9doqk8.jpg"><meta property="article:published_time" content="2023-03-13T08:02:10.533Z"><meta property="article:modified_time" content="2023-03-13T08:12:31.380Z"><meta property="article:author" content="ww"><meta property="article:tag" content="分布式"><meta property="article:tag" content="Redis"><meta property="article:tag" content="高性能"><meta property="article:tag" content="高可用"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/wallhaven-9doqk8.jpg"><link rel="shortcut icon" href="/img/tx.ico"><link rel="canonical" href="https://www.wweicloud.com/2023/03/13/Redis%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体",cht_to_chs:"你已切换为简体",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#49b1f5",bgDark:"#1f1f1f",position:"bottom-left"},source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!0}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Redis基础",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-03-13 16:12:31"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const a=864e5*o,n={value:t,expiry:(new Date).getTime()+a};localStorage.setItem(e,JSON.stringify(n))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const a=document.createElement("script");a.src=e,a.async=!0,a.onerror=o,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)})),e.getCSS=(e,t=!1)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme"),o=window.matchMedia("(prefers-color-scheme: dark)").matches,a=window.matchMedia("(prefers-color-scheme: light)").matches,n=window.matchMedia("(prefers-color-scheme: no-preference)").matches,c=!o&&!a&&!n;if(void 0===t){if(a)activateLightMode();else if(o)activateDarkMode();else if(n||c){const e=(new Date).getHours();e<=6||e>=18?activateDarkMode():activateLightMode()}window.matchMedia("(prefers-color-scheme: dark)").addListener((function(e){void 0===saveToLocal.get("theme")&&(e.matches?activateDarkMode():activateLightMode())}))}else"light"===t?activateLightMode():activateDarkMode();const d=saveToLocal.get("aside-status");void 0!==d&&("hide"===d?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/progress_bar.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"><style>#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags:before{content:"\A";white-space:pre}#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags>.article-meta__separator{display:none}</style><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="screen"'><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",(()=>{preloader.endLoading()}))</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/tx.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/wallhaven-9doqk8.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="青青草原上的菠萝屋"><span class="site-name">青青草原上的菠萝屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-13T08:02:10.533Z" title="发表于 2023-03-13 16:02:10">2023-03-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-13T08:12:31.380Z" title="更新于 2023-03-13 16:12:31">2023-03-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Redis基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="认识NoSQL"><a href="#认识NoSQL" class="headerlink" title="认识NoSQL"></a>认识NoSQL</h2><h3 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h3><ul><li>NoSQL最常见的解释是”<strong>non-relational</strong>“， 很多人也说它是”<strong>Not Only SQL</strong>“</li><li>NoSQL仅仅是一个概念，泛指<strong>非关系型的数据库</strong></li><li>区别于关系数据库，它们不保证关系数据的ACID特性</li><li>NoSQL是一项全新的数据库革命性运动，提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入</li><li>常见的NoSQL数据库有：<code>Redis</code>、<code>MemCache</code>、<code>MongoDB</code>等</li></ul><h3 id="NoSQL与SQL的差异"><a href="#NoSQL与SQL的差异" class="headerlink" title="NoSQL与SQL的差异"></a>NoSQL与SQL的差异</h3><table><thead><tr><th></th><th>SQL</th><th>NoSQL</th></tr></thead><tbody><tr><td>数据结构</td><td>结构化</td><td>非结构化</td></tr><tr><td>数据关联</td><td>关联的</td><td>无关联的</td></tr><tr><td>查询方式</td><td>SQL查询</td><td>非SQL</td></tr><tr><td>事务特性</td><td>ACID</td><td>BASE</td></tr><tr><td>存储方式</td><td>磁盘</td><td>内存</td></tr><tr><td>扩展性</td><td>垂直</td><td>水平</td></tr><tr><td>使用场景</td><td>1）数据结构固定  2）相关业务对数据安全性、一致性要求较高</td><td>1）数据结构不固定  2）对一致性、安全性要求不高  3）对性能要求</td></tr></tbody></table><h2 id="认识Redis"><a href="#认识Redis" class="headerlink" title="认识Redis"></a>认识Redis</h2><p>Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。<br>特征：</p><ul><li>键值（<code>key-value</code>）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li><li>单线程，多路IO复用</li></ul><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><h3 id="安装Redis依赖"><a href="#安装Redis依赖" class="headerlink" title="安装Redis依赖"></a>安装Redis依赖</h3><p>Redis是基于C语言编写的，因此首先需要安装Redis所需要的gcc依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><h3 id="上传安装包并解压"><a href="#上传安装包并解压" class="headerlink" title="上传安装包并解压"></a>上传安装包并解压</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure><p>进入Redis目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.6</span><br></pre></td></tr></table></figure><p>运行编译命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131429499.png" alt="image-20230313142854407"><br>该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h4 id="默认启动"><a href="#默认启动" class="headerlink" title="默认启动"></a>默认启动</h4><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131430640.png" alt="image-20230313143000588"><br>这种启动方式属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止，不推荐使用。</p><h4 id="指定配置启动"><a href="#指定配置启动" class="headerlink" title="指定配置启动"></a>指定配置启动</h4><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p>首先将这个配置文件备份一份：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">守护进程，修改为<span class="built_in">yes</span>后即可后台运行</span></span><br><span class="line">daemonize yes </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">密码，设置后访问Redis必须输入密码</span></span><br><span class="line">requirepass ******</span><br></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监听的端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line">dir .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line">databases 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置redis能够使用的最大内存</span></span><br><span class="line">maxmemory 512mb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line">logfile &quot;redis.log&quot;</span><br></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入redis安装目录</span> </span><br><span class="line">cd /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure><h4 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h4><p>我们也可以通过配置来实现开机自启。<br>首先，新建一个系统服务文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><p>复制以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>记得首先重启一下Redis<br>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure><p>设置开机自启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable redis</span><br></pre></td></tr></table></figure><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样。<br>基本类型：</p><table><thead><tr><th>类型</th><th>样例</th></tr></thead><tbody><tr><td>String</td><td>hello world yyds</td></tr><tr><td>Hash</td><td>{name: “zhangsan”, age: 21}</td></tr><tr><td>List</td><td>[A -&gt; B -&gt; C -&gt; C]</td></tr><tr><td>Set</td><td>{A, B, C}</td></tr><tr><td>SortedSet</td><td>{A: 1, B: 2, C:3}</td></tr></tbody></table><p>特殊类型：</p><table><thead><tr><th>类型</th><th>样例</th></tr></thead><tbody><tr><td>GEO</td><td>{A: (111.1, 112.2)}</td></tr><tr><td>BitMap</td><td>10111011101111</td></tr><tr><td>HyperLog</td><td>01101101011111</td></tr></tbody></table><p>Redis为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ <a target="_blank" rel="noopener" href="https://redis.io/commands">https://redis.io/commands</a> ）可以查看到不同的命令。</p><h3 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h3><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li><code>KEYS</code>：查看符合模板的所有key</li><li><code>DEL</code>：删除一个指定的key</li><li><code>EXISTS</code>：判断key是否存在</li><li><code>EXPIRE</code>：给一个key设置有效期，有效期到期时该key会被自动删除</li><li><code>TTL</code>：查看一个KEY的剩余有效期</li><li><code>help [command]</code> ：查看员工命令的具体用法<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131430398.png" alt="image-20230313143052360"></li></ul><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li><code>string</code>：普通字符串</li><li><code>int</code>：整数类型，可以做自增、自减操作</li><li><code>float</code>：浮点类型，可以做自增、自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m</p><table><thead><tr><th>KEY</th><th>VALUE</th></tr></thead><tbody><tr><td>message</td><td>hello world</td></tr><tr><td>num</td><td>18</td></tr><tr><td>price</td><td>99.9</td></tr></tbody></table><p><strong>String类型常见命令</strong></p><ol><li><code>set</code>：添加或者修改已经存在的一个String类型的键值对</li><li><code>get</code>：根据key获取String类型的value</li><li><code>mset</code>：批量添加多个String类型的键值对</li><li><code>mget</code>：根据多个key获取多个String类型的value</li><li><code>incr</code>：让一个整型的key自增1</li><li><code>incrby</code>：让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li><code>incrbyfloat</code>：让一个浮点类型的数字自增并指定步长</li><li><code>setnx</code>：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li><code>setex</code>：添加一个String类型的键值对，并且指定有效期</li></ol><h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便。</p><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131456713.png" alt="image-20230313145604667"><br><strong>Hash类型常见命令</strong></p><ol><li><code>hset key field value</code>：添加或者修改hash类型key的field的值</li><li><code>hget key field</code>：获取一个hash类型key的field的值</li><li><code>hmset</code>：批量添加多个hash类型key的field的值</li><li><code>hmget</code>：批量获取多个hash类型key的field的值</li><li><code>hgetall</code>：获取一个hash类型的key中的所有的field和value</li><li><code>hkeys</code>：获取一个hash类型的key中的所有的field</li><li><code>hvals</code>：获取一个hash类型的key中的所有的value</li><li><code>hincrby</code>：让一个hash类型key的字段值自增并指定步长</li><li><code>hsetnx</code>：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ol><h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。<br><strong>List类型常见命令</strong></p><ol><li><code>lpush key element ...</code> ：向列表左侧插入一个或多个元素</li><li><code>lpop key</code>：移除并返回列表左侧的第一个元素，没有则返回nil</li><li><code>rpush key elemenet ...</code> ：向列表右侧插入一个或多个元素</li><li><code>rpop key</code>：移除并返回列表右侧的第一个元素</li><li><code>lrange key star end</code>：返回一段角标范围内的所有元素</li><li><code>blpop和brpop</code>：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131514808.png" alt="image-20230313151445756"><br>问：如何利用List结构模拟一个栈?</p><p>答：入口和出口在同一边</p><p>问：如何利用List结构模拟一个队列?</p><p>答：入口和出口在不同边</p><p>如何利用List结构模拟一个阻塞队列?</p><p>答：入口和出口在不同边，出队时采用BLPOP或BRPOP</p><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><p><strong>Set类型常见命令</strong></p><ol><li><code>sadd key member ...</code> ：向set中添加一个或多个元素</li><li><code>srem key member ...</code> ：移除set中的指定元素</li><li><code>scard key</code> ：返回set中元素的个数</li><li><code>sismember key member</code>：判断一个元素是否存在于set中</li><li><code>smembers</code>：获取set中的所有元素</li><li><code>sinter key1 key2 ...</code> ：求key1与key2的交集</li><li><code>sdiff key1 key2 ...</code> ：求key1与key2的差集</li><li><code>sunion key key2 ...</code> ：求key1和key2的并集</li></ol><h3 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。<br>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。<br><strong>SortedSet类型常见命令</strong></p><ol><li><code>zadd key score member</code>：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li><code>zrem key member</code>：删除sorted set中的一个指定元素</li><li><code>zscore key member</code>：获取sorted set中的指定元素的score值</li><li><code>zrank key member</code>：获取sorted set 中的指定元素的排名</li><li><code>zcard key</code>：获取sorted set中的元素个数</li><li><code>zcount key min max</code>：统计score值在给定范围内的所有元素的个数</li><li><code>zincrby key increment member</code>：让sorted set中的指定元素自增，步长为指定的increment值</li><li><code>zrange key min max</code>：按照score排序后，获取指定排名范围内的元素</li><li><code>zrangebyscore key min max</code>：按照score排序后，获取指定score范围内的元素</li><li><code>zdiff、zinter、zunion</code>：求差集、交集、并集</li></ol><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可</p><h3 id="Bitmaps类型"><a href="#Bitmaps类型" class="headerlink" title="Bitmaps类型"></a>Bitmaps类型</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>现代计算机用二进制（位）作为信息的基础单位，1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对</p><p>应的ASCII码分别是97、98、99，对应的二进制分别是01100001、01100010和01100011，如下图<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131514094.png" alt="image-20230313151453059"><br>合理地使用操作位能够有效地提高内存使用率和开发效率。</p><p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><ol><li>Bitmaps本身不是一种数据类型，实际上它就是字符串（key-value），但是它可以对字符串的位进行操作。</li><li>Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131514669.png" alt="image-20230313151457636"></p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ol><li><p><code>setbit key offset value</code>：设置Bitmaps中某个偏移量的值(0或1) offset：偏移量从0开始；</p></li><li><p><code>gitbit key offset</code>：获取Bitmaps中某个偏移量的值；</p></li><li><p><code>bitcount key [start end]</code>：统计字符串被设置为1的bit数一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计</p><p>数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下</p><p>标数，二者皆包含；</p></li><li><p><code>bitop and(or/not/xor) destkey [key...]</code>：bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或）</p><p>操作并将结果保存在destkey中。</p></li></ol><h3 id="HyperLogLog类型"><a href="#HyperLogLog类型" class="headerlink" title="HyperLogLog类型"></a>HyperLogLog类型</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>在Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p><strong>什么是基数</strong></p><p>比如数据集{1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h4 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h4><ol><li><code>pfadd key element [element...]</code>：添加指定元素到HyperLogLog中；</li><li><code>pfcount key [key...]</code>：计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每 天的UV，计算一周的UV可以使用7天的UV合并计算即可；</li><li><code>pfmerge destkey sourcekey [sourcekey...]</code>：将一个或多个HLL合并后的结果存储在另一个HLL中</li></ol><h3 id="Geospatial类型"><a href="#Geospatial类型" class="headerlink" title="Geospatial类型"></a>Geospatial类型</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><h4 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h4><ol><li><p><code>geoadd key longitude latitude member [longitude latitude member...]</code>： 添加地理位置（经度，纬度，名称）;两极无法直接添加，一般会下载城市数据，直接通过Java 程序一次性导入。有效的经度从-180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。当坐标位置超出指定范围时，该命令将会返回一个错误。已经添加的数据，是无法再次往里面添加的。</p></li><li><p><code>geopos key member [member]</code>：获取指定地区的坐标值</p></li><li><p><code>geodist key member1 member2 [m|km|ft|mi]</code>：获取两个位置之间的直线距离</p><ul><li>单位：<ul><li>m 表示单位为米[默认值]。</li><li>km 表示单位为千米。</li><li>mi 表示单位为英里。</li><li>ft 表示单位为英尺。</li></ul></li></ul></li><li><p><code>georadius key longitude latitude radius m|km|ft|mi</code>：以给定的经纬度为中心，找出某一半径内的元素</p></li></ol><h2 id="发布和订阅"><a href="#发布和订阅" class="headerlink" title="发布和订阅"></a>发布和订阅</h2><h3 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a>什么是发布和订阅</h3><p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。<br>Redis 客户端可以订阅任意数量的频道。</p><h3 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h3><ol><li>客户端可以订阅频道如下图</li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131515848.png" alt="image-20230313151506810"></p><ol start="2"><li>当这个频道发布消息后，消息就会发送给订阅的客户端</li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131515664.png" alt="image-20230313151509632"></p><h3 id="发布订阅命令行实现"><a href="#发布订阅命令行实现" class="headerlink" title="发布订阅命令行实现"></a>发布订阅命令行实现</h3><ol><li>打开一个客户端订阅channel1</li></ol><p>SUBSCRIBE channel1<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131515820.png" alt="image-20230313151515782"></p><ol start="2"><li>打开另一个客户端，给channel1发布消息</li></ol><p>PUBLISH channel1 hello<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131515481.png" alt="image-20230313151522449"><br>返回值1是订阅者数量</p><ol start="3"><li>打开另一个客户端查看消息</li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131515719.png" alt="image-20230313151542679"></p><blockquote><p>发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息</p></blockquote><h2 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在Redis官网中提供了各种语言的客户端，地址：<a target="_blank" rel="noopener" href="https://redis.io/clients">https://redis.io/clients</a><br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131516288.png" alt="image-20230313151616228"><br>其中Jedis、lettuce、Redisson是比较常见的<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131516967.png" alt="image-20230313151621889" style="zoom:67%"></p><ul><li>Jedis：以Redis命令作为方法名称，学习成本低，简单实用。但是Jedis实例是线程不安全的，多线程环境下需要基于连接池来使用</li><li>lettuce：Lettuce是基于Netty实现的，支持同步、异步和响应式编程方式，并且是线程安全的。支持Redis的哨兵模式、集群模式和管道模式。</li><li>Redission：Redisson是一个基于Redis实现的分布式、可伸缩的Java数据结构集合。包含了诸如Map、Queue、Lock、 Semaphore、AtomicLong等强大功能。</li></ul><p>其中，Jedis和lettuce又被Spring Data Redis整合。</p><p>注意：在远程连接Redis时，修改以下配置并开放6379端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected-mode no</span><br></pre></td></tr></table></figure><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><p>以Redis命令作为方法名称，学习成本低，简单实用。但是Jedis实例是线程不安全的，多线程环境下需要基于连接池来使用。<br>Jedis的官网地址： <a target="_blank" rel="noopener" href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p><h4 id="Jedis快速入门"><a href="#Jedis快速入门" class="headerlink" title="Jedis快速入门"></a>Jedis快速入门</h4><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>建立连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 建立连接</span></span><br><span class="line">	jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;ip地址&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">	<span class="comment">// 设置密码</span></span><br><span class="line">	jedis.auth(<span class="string">&quot;redis密码&quot;</span>);</span><br><span class="line">	<span class="comment">// 选择库</span></span><br><span class="line">	jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 插入数据，方法名称就是redis命令名称</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">	<span class="comment">// 获取数据</span></span><br><span class="line">	System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>释放资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 释放资源 交还</span></span><br><span class="line">	<span class="keyword">if</span> (jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">		jedis.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h4><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池代替Jedis的直连方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPoll;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">// 最多连接数</span></span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 最大空闲连接</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        <span class="comment">// 最小空闲连接</span></span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 等待时长 毫秒 -1永久</span></span><br><span class="line">        jedisPoolConfig.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建连接池对象</span></span><br><span class="line">        jedisPoll = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig, <span class="string">&quot;ip地址&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>, <span class="string">&quot;redis密码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPoll.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，可将快速入门第二步修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 建立连接</span></span><br><span class="line">	<span class="comment">// jedis = new Jedis(&quot;ip地址&quot;, 6379);</span></span><br><span class="line">    jedis = JedisConnectionFactory.getJedis();</span><br><span class="line">	<span class="comment">// 设置密码</span></span><br><span class="line">	jedis.auth(<span class="string">&quot;密码&quot;</span>);</span><br><span class="line">	<span class="comment">// 选择库</span></span><br><span class="line">	jedis.select(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h3><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis</p><p>官网地址：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><p>它的特征如下：</p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><table><thead><tr><th>API</th><th>返回值类型</th><th>说明</th></tr></thead><tbody><tr><td>redisTemplate.opsForValue()</td><td>ValueOperations</td><td>操作String类型数据</td></tr><tr><td>redisTemplate.opsForHash()</td><td>HashOperations</td><td>操作Hash类型数据</td></tr><tr><td>redisTemplate.opsForList()</td><td>ListOperations</td><td>操作List类型数据</td></tr><tr><td>redisTemplate.opsForSet()</td><td>SetOperations</td><td>操作Set类型数据</td></tr><tr><td>redisTemplate.opsForZSet()</td><td>ZSetOperations</td><td>操作SortedSet类型数据</td></tr><tr><td>redisTemplate</td><td></td><td>通用的命令</td></tr></tbody></table><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Redis依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 连接池依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">114.115</span><span class="number">.177</span><span class="number">.60</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">ww1103</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure></li><li><p>注入RedisTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">	redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">	<span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;name: &quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="SpringDataRedis序列化方式"><a href="#SpringDataRedis序列化方式" class="headerlink" title="SpringDataRedis序列化方式"></a>SpringDataRedis序列化方式</h4><p>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK序列化，得到的结果是这样的：<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131517855.png" alt="image-20230313151758817"><br>缺点：可读性差、内存占用较大。</p><p>我们可以自定义RedisTemplate的序列化方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2.创建连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 3.创建JSON序列化工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 4.设置key的序列化 采用string序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 5.设置value序列化 采用json序列化</span></span><br><span class="line">        template.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="comment">// 6。返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span>&#123;</span><br><span class="line">	redisTemplate.opsForValue().set(<span class="string">&quot;user:1&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">22</span>));</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;user:1&quot;</span>);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题，如图：<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131519155.png" alt="image-20230313151942117"><br>为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p><p>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，</p><p>手动完成对象的序列化和反序列化。</p><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131520608.png" alt="image-20230313152000533"></p><p>Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span>&#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;武汉&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">city</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;city&quot;</span>);</span><br><span class="line">    System.out.println(city);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小强&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    <span class="comment">// 手动序列化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">    <span class="comment">// 写入数据</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:2&quot;</span>, json);</span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:2&quot;</span>);</span><br><span class="line">    <span class="comment">// 手动反序列化</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(s, User.class);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHash</span><span class="params">()</span>&#123;</span><br><span class="line">    stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:3&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">    stringRedisTemplate.opsForHash().put(<span class="string">&quot;user:3&quot;</span>,<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line">    Map&lt;Object, Object&gt; entries = stringRedisTemplate.opsForHash().entries(<span class="string">&quot;user:3&quot;</span>);</span><br><span class="line">    System.out.println(entries);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>RedisTemplate的两种序列化实践方案：</p><p>方案一：</p><ol><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ol><p>方案二：</p><ol><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ol><h2 id="事务-锁机制"><a href="#事务-锁机制" class="headerlink" title="事务_锁机制"></a>事务_锁机制</h2><h3 id="Redis事务定义"><a href="#Redis事务定义" class="headerlink" title="Redis事务定义"></a>Redis事务定义</h3><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。<br>Redis事务的主要作用就是串联多个命令防止别的命令插队。</p><h3 id="Multi、Exec、Discard"><a href="#Multi、Exec、Discard" class="headerlink" title="Multi、Exec、Discard"></a>Multi、Exec、Discard</h3><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。组队的过程中可以通</p><p>过discard来放弃组队。</p><p><strong>multi</strong>：标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</p><p><strong>exec</strong>：执行所有事务块内的命令。假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这</p><p>个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</p><p><strong>discard</strong>：取消事务，放弃执行事务块内的所有命令。如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131521588.png" alt="image-20230313152159541"><br><strong>实现</strong><br>组队成功，提交成功<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131522897.png" alt="image-20230313152203854"><br>放弃组队<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131522607.png" alt="image-20230313152207567"></p><h3 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h3><ol><li><p>组队中某个命令出现了错误的报告，执行时整个队列都会被取消。</p><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131522153.png" alt="image-20230313152222110"></p></li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131522157.png" alt="image-20230313152259114"></p><ol start="2"><li>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131523114.png" alt="image-20230313152334073"></p><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131523877.png" alt="image-20230313152328838"></p><h3 id="为什么要做成事务"><a href="#为什么要做成事务" class="headerlink" title="为什么要做成事务"></a>为什么要做成事务</h3><p>想想一个场景：有很多人有你的账户，同时去参加双十一抢购</p><h3 id="事务冲突问题"><a href="#事务冲突问题" class="headerlink" title="事务冲突问题"></a>事务冲突问题</h3><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>一个请求想给金额减8000<br>一个请求想给金额减5000<br>一个请求想给金额减1000<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131523020.png" alt="image-20230313152358971"></p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131524588.png" alt="image-20230313152403539"></p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p><strong>乐观锁(Optimistic Lock), <strong>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131524503.png" alt="image-20230313152411455"></p><h4 id="WATCH-key-key…"><a href="#WATCH-key-key…" class="headerlink" title="WATCH key [key…]"></a>WATCH key [key…]</h4><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131524925.png" alt="image-20230313152415876"></p><h4 id="unwatch"><a href="#unwatch" class="headerlink" title="unwatch"></a>unwatch</h4><p>取消WATCH 命令对所有key 的监视。<br>如果在执行WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。<br>因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</p><h3 id="Redis事务三特性"><a href="#Redis事务三特性" class="headerlink" title="Redis事务三特性"></a>Redis事务三特性</h3><ol><li>单独的隔离操作</li></ol><ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li></ul><ol start="2"><li>没有隔离级别的概念</li></ol><ul><li>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</li></ul><ol start="3"><li>不保证原子性</li></ol><ul><li>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</li></ul><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote><p>How Redis writes data to disk (append-only files, snapshots, etc.)<br>Persistence refers to the writing of data to durable storage, such as a solid-state disk (SSD). Redis itself provides a range of persistence options:</p><ul><li><strong>RDB</strong> (Redis Database): The RDB persistence performs point-in-time snapshots of your dataset at specified intervals.</li><li><strong>AOF</strong> (Append Only File): The AOF persistence logs every write operation received by the server, that will be played again at server startup, reconstructing the original dataset. Commands are logged using the same format as the Redis protocol itself, in an append-only fashion. Redis is able to rewrite the log in the background when it gets too big.</li><li><strong>No persistence</strong>: If you wish, you can disable persistence completely, if you want your data to just exist as long as the server is running.</li><li><strong>RDB + AOF</strong>: It is possible to combine both AOF and RDB in the same instance. Notice that, in this case, when Redis restarts the AOF file will be used to reconstruct the original dataset since it is guaranteed to be the most complete.</li></ul><p>The most important thing to understand is the different trade-offs between the RDB and AOF persistence.</p><p>Redis 如何将数据写入磁盘（仅追加文件、快照等）<br>持久性是指将数据写入持久存储，例如固态磁盘 （SSD）。Redis 本身提供了一系列持久性选项：</p><ul><li><strong>RDB</strong>（Redis 数据库）：RDB 持久性按指定的时间间隔执行数据集的时间点快照。</li><li><strong>AOF</strong>（仅追加文件）：AOF 持久性记录服务器收到的每个写入操作，这些操作将在服务器启动时再次播放，重建原始数据集。命令使用与 Redis 协议本身相同的格式以仅追加的方式进行记录。Redis能够在日志变得太大时在后台重写日志。</li><li><strong>无持久性</strong>：如果您愿意，可以完全禁用持久性，如果您希望数据在服务器运行期间就存在。</li><li><strong>RDB + AOF</strong>：可以在同一实例中同时组合 AOF 和 RDB。请注意，在这种情况下，当 Redis 重新启动时，将使用 AOF 文件来重建原始数据集，因为它保证是最完整的。</li></ul><p>要了解的最重要的事情是 RDB 和 AOF 持久性之间的不同权衡。</p></blockquote><p>Redis提供了2个不同形式的持久化</p><ul><li>RDB（Redis DataBase）</li><li>AOF（Append Of File）</li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><h4 id="官网介绍"><a href="#官网介绍" class="headerlink" title="官网介绍"></a>官网介绍</h4><blockquote><h5 id="RDB-advantages"><a href="#RDB-advantages" class="headerlink" title="RDB advantages"></a>RDB advantages</h5><ul><li>RDB is a very compact single-file point-in-time representation of your Redis data. RDB files are perfect for backups. For instance you may want to archive your RDB files every hour for the latest 24 hours, and to save an RDB snapshot every day for 30 days. This allows you to easily restore different versions of the data set in case of disasters.</li><li>RDB is very good for disaster recovery, being a single compact file that can be transferred to far data centers, or onto Amazon S3 (possibly encrypted).</li><li>RDB maximizes Redis performances since the only work the Redis parent process needs to do in order to persist is forking a child that will do all the rest. The parent process will never perform disk I&#x2F;O or alike.</li><li>RDB allows faster restarts with big datasets compared to AOF.</li><li>On replicas, RDB supports partial resynchronizations after restarts and failovers.</li></ul><h5 id="RDB-disadvantages"><a href="#RDB-disadvantages" class="headerlink" title="RDB disadvantages"></a>RDB disadvantages</h5><ul><li>RDB is NOT good if you need to minimize the chance of data loss in case Redis stops working (for example after a power outage). You can configure different <em>save points</em> where an RDB is produced (for instance after at least five minutes and 100 writes against the data set, you can have multiple save points). However you’ll usually create an RDB snapshot every five minutes or more, so in case of Redis stopping working without a correct shutdown for any reason you should be prepared to lose the latest minutes of data.</li><li>RDB needs to fork() often in order to persist on disk using a child process. fork() can be time consuming if the dataset is big, and may result in Redis stopping serving clients for some milliseconds or even for one second if the dataset is very big and the CPU performance is not great. AOF also needs to fork() but less frequently and you can tune how often you want to rewrite your logs without any trade-off on durability.</li></ul><h5 id="RDB的优势"><a href="#RDB的优势" class="headerlink" title="RDB的优势"></a>RDB的优势</h5><ul><li>RDB 是 Redis 数据的非常紧凑的单文件时间点表示形式。RDB文件非常适合备份。例如，您可能希望在最近 24 小时内每小时存档一次 RDB 文件，并在 30 天内每天保存一个 RDB 快照。这使您可以在发生灾难时轻松还原数据集的不同版本。</li><li>RDB 非常适合灾难恢复，它是一个可以传输到远程数据中心或 Amazon S3（可能加密）的单个紧凑文件。</li><li>RDB最大限度地提高了Redis的性能，因为Redis父进程为了持久化而需要做的唯一工作就是分叉一个将完成其余所有工作的子进程。父进程永远不会执行磁盘 I&#x2F;O 或类似操作。</li><li>与 AOF 相比，RDB 允许使用大数据集更快地重新启动。</li><li>在副本上，RDB 支持在重新启动和故障转移后进行部分重新同步。</li></ul><h5 id="RDB-的缺点"><a href="#RDB-的缺点" class="headerlink" title="RDB 的缺点"></a>RDB 的缺点</h5><ul><li>如果您需要在 Redis 停止工作（例如停电后）将数据丢失的可能性降至最低，则 RDB 并不好。您可以在生成 RDB 的位置配置不同的_保存点_（例如，在对数据集进行至少 5 分钟和 100 次写入后，可以有多个保存点）。但是，您通常会每五分钟或更长时间创建一个RDB快照，因此，如果Redis因任何原因在没有正确关闭的情况下停止工作，您应该准备好丢失最新几分钟的数据。</li><li>RDB 经常需要 fork（） 才能使用子进程保留在磁盘上。如果数据集很大，fork（） 可能会很耗时，并且可能导致 Redis 停止为客户端提供服务几毫秒，如果数据集非常大并且 CPU 性能不是很好，甚至停止一秒钟。AOF还需要分叉（）但频率较低，您可以调整重写日志的频率，而无需在持久性上进行任何权衡。</li></ul></blockquote><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p><h4 id="备份是如何执行的"><a href="#备份是如何执行的" class="headerlink" title="备份是如何执行的"></a>备份是如何执行的</h4><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。</p><p>整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比</p><p>AOF方式更加的高效。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</p><h4 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h4><ul><li>Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程；</li><li>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术”；</li><li>一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li></ul><h4 id="RDB持久化流程"><a href="#RDB持久化流程" class="headerlink" title="RDB持久化流程"></a>RDB持久化流程</h4><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131527012.png" alt="image-20230313152720972"></p><h4 id="dump-rdb文件"><a href="#dump-rdb文件" class="headerlink" title="dump.rdb文件"></a>dump.rdb文件</h4><p>在redis.conf中配置文件名称，默认为dump.rdb<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131527834.png" alt="image-20230313152752796"></p><h4 id="配置位置"><a href="#配置位置" class="headerlink" title="配置位置"></a>配置位置</h4><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131527355.png" alt="image-20230313152759319"></p><h4 id="如何触发RDB快照，保持策略"><a href="#如何触发RDB快照，保持策略" class="headerlink" title="如何触发RDB快照，保持策略"></a>如何触发RDB快照，保持策略</h4><h5 id="配置文件中默认的快照配置"><a href="#配置文件中默认的快照配置" class="headerlink" title="配置文件中默认的快照配置"></a>配置文件中默认的快照配置</h5><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131528968.png" alt="image-20230313152804927"><br>输入save 20 3保存，意思是20秒内有3个key发生变化就持久化<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131528297.png" alt="image-20230313152812240"></p><h5 id="命令save-和-bgsave"><a href="#命令save-和-bgsave" class="headerlink" title="命令save 和 bgsave"></a>命令save 和 bgsave</h5><p><code>save</code> ：save时只管保存，其它不管，全部阻塞。手动保存。不建议。<br><code>bgsave</code>：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。<br>可以通过lastsave 命令获取最后一次成功执行快照的时间。</p><h5 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h5><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。</p><h5 id="SNAPSHOTTING快照"><a href="#SNAPSHOTTING快照" class="headerlink" title="SNAPSHOTTING快照"></a><strong>SNAPSHOTTING快照</strong></h5><h5 id="Save"><a href="#Save" class="headerlink" title="Save"></a>Save</h5><p>格式：<code>save 秒钟 写操作次数</code></p><p>RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件</p><p>默认是1分钟内改了1万次，或5分钟内改了10次，或15分钟内改了1次。</p><p>禁用：不设置save指令，或者给save传入空字符串。</p><h5 id="stop-writes-on-bgsave-error"><a href="#stop-writes-on-bgsave-error" class="headerlink" title="stop-writes-on-bgsave-error"></a>stop-writes-on-bgsave-error</h5><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131530149.png" alt="image-20230313153004109"><br>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes。</p><h5 id="rdbcompression压缩文件"><a href="#rdbcompression压缩文件" class="headerlink" title="rdbcompression压缩文件"></a>rdbcompression压缩文件</h5><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131530516.png" alt="image-20230313153016475"><br>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。<br>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes。</p><h5 id="rdbchecksum检查完整性"><a href="#rdbchecksum检查完整性" class="headerlink" title="rdbchecksum检查完整性"></a>rdbchecksum检查完整性</h5><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131530162.png" alt="image-20230313153030122"><br>在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能，推荐yes。</p><h5 id="RDB的备份"><a href="#RDB的备份" class="headerlink" title="RDB的备份"></a>RDB的备份</h5><p>先通过 <code>config get dir</code> 查询rdb文件的目录，将*.rdb的文件拷贝到别的地方<br>rdb的恢复</p><ol><li>关闭Redis</li><li>先把备份的文件拷贝到工作目录下cp dump2.rdb dump.rdb</li><li>启动Redis, 备份数据会直接加载</li></ol><h4 id="RDB优势"><a href="#RDB优势" class="headerlink" title="RDB优势"></a>RDB优势</h4><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131531699.png" alt="image-20230313153102657"></p><h4 id="RDB劣势"><a href="#RDB劣势" class="headerlink" title="RDB劣势"></a>RDB劣势</h4><ul><li>Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑</li><li>虽然Redis在fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。</li><li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会丢失最后一次快照后的所有修改。</li></ul><h4 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h4><p>动态停止RDB：<code>redis-cli config set save &quot;&quot;</code> #save后给空值，表示禁用保存策略。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ul><li>RDB是一个非常紧凑的文件；</li><li>RDB在保存RDB文件时，父进程唯一需要做的就是fork出一个字进程，接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化Redis的性能；</li><li>与AOF相比，在恢复大的数据集的时候，RDB方式会更快一些。</li></ul><hr><ul><li>数据丢失风险大；</li><li>RDB需要经常Fork子进程来保存数据集到磁盘上，当数据集比较大的时候，fork的过程是非常耗时的，可能会导致Redis在一些毫秒级不能响应客户端请求。</li></ul><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p>以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><h4 id="AOF持久化流程"><a href="#AOF持久化流程" class="headerlink" title="AOF持久化流程"></a>AOF持久化流程</h4><ol><li>客户端的请求写命令会被append追加到AOF缓冲区内；</li><li>AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</li><li>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</li><li>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的。</li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131533621.png" alt="image-20230313153341578"></p><h4 id="AOF默认不开启"><a href="#AOF默认不开启" class="headerlink" title="AOF默认不开启"></a>AOF默认不开启</h4><p>可以在redis.conf中配置文件名称，默认为 appendonly.aof，将appendonly no改为yes开启<br>AOF文件的保存路径，同RDB的路径一致。<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131534641.png" alt="image-20230313153430595"></p><h4 id="AOF和RDB同时开启，听谁的"><a href="#AOF和RDB同时开启，听谁的" class="headerlink" title="AOF和RDB同时开启，听谁的"></a>AOF和RDB同时开启，听谁的</h4><p>AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）</p><h4 id="AOF启动-x2F-恢复-x2F-修复"><a href="#AOF启动-x2F-恢复-x2F-修复" class="headerlink" title="AOF启动&#x2F;恢复&#x2F;修复"></a>AOF启动&#x2F;恢复&#x2F;修复</h4><ul><li>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</li><li>正常恢复<ol><li>修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li><li>恢复：重启redis然后重新加载</li></ol></li><li>异常恢复<ol><li>修改默认的appendonly no，改为yes</li><li>如遇到AOF文件损坏，通过&#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-check-aof–fix appendonly.aof进行恢复</li><li>备份被写坏的AOF文件</li><li>恢复：重启redis，然后重新加载</li></ol></li></ul><h4 id="AOF同步频率设置"><a href="#AOF同步频率设置" class="headerlink" title="AOF同步频率设置"></a>AOF同步频率设置</h4><ul><li>appendfsync always：始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</li><li>appendfsync everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</li><li>appendfsync no：redis不主动进行同步，把同步时机交给操作系统。</li></ul><h4 id="Rewrite压缩"><a href="#Rewrite压缩" class="headerlink" title="Rewrite压缩"></a>Rewrite压缩</h4><h5 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h5><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集.可以使用命令bgrewriteaof。</p><h5 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h5><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，redis4.0版本后的重写，是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。<br>no-appendfsync-on-rewrite：<br>如果no-appendfsync-on-rewrite&#x3D;yes ,不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）<br>如果no-appendfsync-on-rewrite&#x3D;no, 还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）<br><strong>触发机制，何时重写</strong><br>Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。<br>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写。<br>auto-aof-rewrite-percentage：设置重写的基准值，文件达到100%时开始重写（文件是原来重写后文件的2倍时触发）<br>auto-aof-rewrite-min-size：设置重写的基准值，最小文件64MB。达到这个值开始重写。<br>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB<br>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,<br>如果Redis的AOF当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis会对AOF进行重写。</p><h5 id="重写流程"><a href="#重写流程" class="headerlink" title="重写流程"></a>重写流程</h5><ol><li>bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</li><li>主进程fork出子进程执行重写操作，保证主进程不会阻塞。</li><li>子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</li><li>①子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。②主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</li><li>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131535553.png" alt="image-20230313153513498"></p><h4 id="AOF优势"><a href="#AOF优势" class="headerlink" title="AOF优势"></a>AOF优势</h4><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131535655.png" alt="image-20230313153520614"></p><ul><li>备份机制更稳健，丢失数据概率更低；</li><li>可读的日志文本，通过操作AOF更稳健，可以处理误操作。</li></ul><h4 id="AOF劣势"><a href="#AOF劣势" class="headerlink" title="AOF劣势"></a>AOF劣势</h4><ul><li>比起RDB占用更多的磁盘空间；</li><li>恢复备份速度要慢；</li><li>每次读写都同步的话，有一定的性能压力；</li><li>存在个别bug，造成恢复不能。</li></ul><h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><ul><li>AOF文件是一个只进行追加的日志文件</li><li>Redis可以在AOF文件体积变得过大时，自动地在后台对AOF进行重写</li><li>AOF文件有序的保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此AOF文件的内容非常容易被人读懂，对文件进行分析也很轻松</li><li>对于相同的数据集来说，AOF文件的体积通常要大于RDB文件的体积</li><li>根据所使用的fsync策略，AOF的速度可能会慢于RDB</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><h4 id="用哪个好"><a href="#用哪个好" class="headerlink" title="用哪个好"></a>用哪个好</h4><p>官方推荐两个都启用。</p><p>如果对数据不敏感，可以选单独用RDB。不建议单独用AOF，因为可能会出现Bug。如果只是做纯内存缓存，可以都不用。</p><h4 id="官方建议"><a href="#官方建议" class="headerlink" title="官方建议"></a>官方建议</h4><ul><li>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</li><li>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.</li><li>Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</li><li>只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式.</li><li>同时开启两种持久化方式</li><li>在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</li><li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？</li><li>建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</li><li>性能建议</li></ul><p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。</p><p>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。</p><p>代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</p><p>只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。</p><p>默认超过原大小100%大小时重写可以改到适当的数值。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p>主机数据更新后根据配置和策略，自动同步到备机的master&#x2F;slaver机制，master以写为主，slave以读为主</p><h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><ul><li>读写分离，性能扩展</li><li>容灾快速恢复</li></ul><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131536715.png" alt="image-20230313153618667"></p><h3 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h3><ol><li>拷贝多个redis.conf文件include(写绝对路径)</li><li>开启daemonize yes</li><li>Pid 文件名字 pidfile</li><li>指定端口port</li><li>Log文件名字</li><li>dump.rdb名字 dbfilename</li><li>appendonly 关掉或者换名字</li></ol><h3 id="搭建一主两从"><a href="#搭建一主两从" class="headerlink" title="搭建一主两从"></a>搭建一主两从</h3><ol><li>新建一个目录，将redis.conf复制进来</li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131536776.png" alt="image-20230313153638722"></p><ol start="2"><li><p>创建3个配置文件，分别命名为redis6379.conf redis6380.conf redis6381.conf</p></li><li><p>关掉AOF</p></li><li><p>三个配置文件分别写入以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line"></span><br><span class="line">include /myredis/redis.conf</span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line">port 6380</span><br><span class="line">dbfilename dump6380.rdb</span><br><span class="line"></span><br><span class="line">include /myredis/redis.conf</span><br><span class="line">pidfile /var/run/redis_6381.pid</span><br><span class="line">port 6381</span><br><span class="line">dbfilename dump6381.rdb</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131537434.png" alt="image-20230313153710393"></p></li><li><p>启动三台redis</p></li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131537027.png" alt="image-20230313153713986"></p><ol start="6"><li>查看当前主机的运行状态，此时全是master</li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131537694.png" alt="image-20230313153716655"></p><ol start="7"><li>在从机上执行 <code>slaveof 主机ip 端口号</code></li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131537922.png" alt="image-20230313153720858"><br>此时已经搭建完成了</p><ol start="8"><li>测试</li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131537046.png" alt="image-20230313153740002"><br>可以发现，从机只能读不能写</p><h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><ul><li>Slave启动成功连接到master后会发送一个sync命令</li><li>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步</li><li>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li><li>增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</li><li>但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</li></ul><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131538669.png" alt="image-20230313153808627"></p><h3 id="常见三招"><a href="#常见三招" class="headerlink" title="常见三招"></a>常见三招</h3><h4 id="一主两仆"><a href="#一主两仆" class="headerlink" title="一主两仆"></a>一主两仆</h4><p><strong>问题1</strong> 当从服务器挂掉了，重新加入会怎么样<br>答：从服务器挂掉，再启动会变回master，通过命令变成slave会复制主上所有的键<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131538507.png" alt="image-20230313153817459"><br><strong>问题2</strong> 当主机挂掉会怎么样<br>答：从服务器还是从服务器，从服务器上主服务器的信息会变成down，当主服务器好了又up<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131538090.png" alt="image-20230313153823029"></p><h4 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h4><p>上一个Slave可以是下一个slave的Master，Slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。<br>在某个从服务器中用<code>slaveof &lt;ip&gt; &lt;port&gt;</code><br>中途变更转向：会清除之前的数据，重新建立拷贝最新的<br>风险是一旦某个slave宕机，后面的slave都没法备份<br>主机挂了，从机还是从机，无法写数据了</p><h4 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h4><p>当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。<br>用slaveof no one 将从机变为主机。</p><h3 id="哨兵模式-sentinel"><a href="#哨兵模式-sentinel" class="headerlink" title="哨兵模式(sentinel)"></a>哨兵模式(sentinel)</h3><h4 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h4><p><strong>客为主的自动版</strong>，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131538755.png" alt="image-20230313153849708"></p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol><li><p>调整为一主二仆模式</p></li><li><p>自定义的&#x2F;myredis目录下新建sentinel.conf文件，名字绝不能错</p></li><li><p>在sentinel.conf中写入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p>其中mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。</p></li><li><p>启动哨兵redis-sentinel &#x2F;myredis&#x2F;sentinel.conf</p></li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131538098.png" alt="image-20230313153857040"></p><ol start="5"><li>当主机宕机，大概等十几秒，哨兵会选择新的主机</li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131539256.png" alt="image-20230313153906191"></p><h4 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h4><p>由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</p><h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><ol><li>从下线的主服务器的所有从服务器里面挑选一个，将其变成主服务器，选择条件一次为：<ol><li>选择优先级靠前的</li><li>选择偏移量最大的</li><li>选择runid最小的从服务</li></ol></li><li>挑选出新的主服务之后，sentinel向原主服务的从服务发送slaveof新主服务的命令，复制新的master</li><li>当已下线的服务重新上线时，sentinel会向其发送slaveof命令，让其成为新主的从</li></ol><p>优先级在redis.conf中默认：slave-priority 100，值越小优先级越高<br>每个偏移量是指获得原主机数据最全的<br>每个redis实例启动后都会随机生成一个40位的runid</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>量不够，redis如何进行扩容？并发写操作，redis如何分摊？</p><p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p><p>之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是无中心化集群配置。</p><h3 id="什么是集群"><a href="#什么是集群" class="headerlink" title="什么是集群"></a>什么是集群</h3><p>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N。</p><p>Redis 集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求。</p><h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><ol><li><p>删除rdb和aof文件</p></li><li><p>创建几个实例，我这里是6个，6379、6380、6381、6389、6390、6391</p></li><li><p>配置基本信息</p><ul><li>开启daemonrize yes</li><li>Pid 文件名字</li><li>指定端口</li><li>Log 文件名字</li><li>Dump.rdb 名字</li><li>Appendonly关掉或者换名字</li></ul></li><li><p>redis cluster配置修改</p><ol><li>cluster-enabled yes 打开集群模式</li><li>cluster-config-file nodes-6379.conf 设定节点配置文件名</li><li>cluster-node-timeout 15000 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure></li></ol></li><li><p>启动6个实例，同时节点的配置文件也自动创建了</p></li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131539678.png" alt="image-20230313153942626"><br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131539101.png" alt="image-20230313153948054"></p><ol start="6"><li>将6个节点合成一个集群</li></ol><p>在redis的src目录下执行以下语句，我这里是 <code>cd /opt/redis-6.2.1/src</code><br>此处不要用127.0.0.1， 请用真实IP地址<br>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 192.168.184.128:6379 192.168.184.128:6380 192.168.184.128:6381 192.168.184.128:6389 192.168.184.128:6390 192.168.184.128:6391</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131540100.png" alt="image-20230313154012042"><br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131540048.png" alt="image-20230313154015986"><br>搭建完成</p><ol start="7"><li>测试</li></ol><ul><li>普通方式登录</li></ul><p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群方式登录。</p><ul><li>集群方式登录</li></ul><p>-c 采用集群策略连接，设置数据会自动切换到相应的写主机<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131540819.png" alt="image-20230313154023778"></p><h3 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131541188.png" alt="image-20230313154113141"></p><h3 id="Redis如何分配节点的"><a href="#Redis如何分配节点的" class="headerlink" title="Redis如何分配节点的"></a>Redis如何分配节点的</h3><p>一个集群至少要有三个主节点。<br>选项–cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。<br>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上。</p><h3 id="什么是slots"><a href="#什么是slots" class="headerlink" title="什么是slots"></a>什么是slots</h3><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131541226.png" alt="image-20230313154118188"><br>一个Redis 集群包含 16384 个插槽（hash slot），数据库中的每个键都属于这16384 个插槽的其中一个，<br>集群使用公式CRC16(key) % 16384 来计算键 key 属于哪个槽，其中CRC16(key) 语句用于计算键key 的CRC16 校验和。<br>集群中的每个节点负责处理一部分插槽。</p><ul><li>举个例子，如果一个集群可以有主节点，其中：<ul><li>节点A 负责处理 0 号至5460 号插槽。</li><li>节点B 负责处理 5461 号至10922 号插槽。</li><li>节点C 负责处理 10923 号至16383 号插槽</li></ul></li></ul><h3 id="在集群中录入值"><a href="#在集群中录入值" class="headerlink" title="在集群中录入值"></a>在集群中录入值</h3><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。<img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131541106.png" alt="image-20230313154132057"><br>redis-cli客户端提供了 –c 参数实现自动重定向。<br>如redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。<br>不在一个slot下的键值，是不能使用mget,mset等多键操作。<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131541211.png" alt="image-20230313154142162"><br>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131541845.png" alt="image-20230313154146801"></p><h3 id="查询集群中的值"><a href="#查询集群中的值" class="headerlink" title="查询集群中的值"></a>查询集群中的值</h3><p>查询插槽中的值，如果不在同一个服务器是查不到的<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131541166.png" alt="image-20230313154151118"></p><h3 id="故障恢复-1"><a href="#故障恢复-1" class="headerlink" title="故障恢复"></a>故障恢复</h3><p>如果主节点下线？从节点能否自动升为主节点？注意：<strong>15秒超时</strong><br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131542980.png" alt="image-20230313154200924"><br>主节点恢复后，主从关系会如何？主节点回来变成从机。<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131542711.png" alt="image-20230313154204659"><br>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么，整个集群都挂掉</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</p><p>redis.conf中的参数 cluster-require-full-coverage</p><h3 id="集群的Jedis开发"><a href="#集群的Jedis开发" class="headerlink" title="集群的Jedis开发"></a>集群的Jedis开发</h3><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。<br>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisClusterTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">     Set&lt;HostAndPort&gt;set =<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;HostAndPort&gt;();</span><br><span class="line">     set.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.31.211&quot;</span>,<span class="number">6379</span>));</span><br><span class="line">     JedisCluster jedisCluster=<span class="keyword">new</span> <span class="title class_">JedisCluster</span>(set);</span><br><span class="line">     jedisCluster.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">     System.out.println(jedisCluster.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集群提供的好处"><a href="#集群提供的好处" class="headerlink" title="集群提供的好处"></a>集群提供的好处</h3><ul><li>实现扩容</li><li>分摊压力</li><li>无中心配置相对简单</li></ul><h3 id="集群的不足之处"><a href="#集群的不足之处" class="headerlink" title="集群的不足之处"></a>集群的不足之处</h3><ul><li>多键操作是不被支持的</li><li>多键的Redis事务是不被支持的。lua脚本不被支持</li><li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。</li></ul><h2 id="Redis应用问题解决"><a href="#Redis应用问题解决" class="headerlink" title="Redis应用问题解决"></a>Redis应用问题解决</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>问题描述</strong><br>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131542293.png" alt="image-20230313154253231"><br><strong>解决方案</strong><br>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p><ol><li>对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟；</li><li>设置可访问的名单（白名单）：使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问；</li><li>采用布隆过滤器：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。）将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力；</li><li>进行实时监控：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131542795.png" alt="image-20230313154258730"></p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>问题描述</strong><br>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131543179.png" alt="image-20230313154303127"><br><strong>解决方案</strong><br>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p><ol><li>预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</li><li>实时调整：现场监控哪些数据热门，实时调整key的过期时长</li><li>使用锁：<ol><li>就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。</li><li>先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key</li><li>当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；</li><li>当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</li></ol></li></ol><p><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131543310.png" alt="image-20230313154310264"></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>问题描述</strong><br>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<br>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key正常访问。<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131543764.png" alt="image-20230313154318702"><br>缓存失效瞬间<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131550518.png" alt="image-20230313155054456"><br><strong>解决方案</strong><br>缓存失效时的雪崩效应对底层系统的冲击非常可怕！</p><ol><li><p>构建多级缓存架构：nginx缓存 + redis缓存 +其他缓存（ehcache等）。</p></li><li><p>使用锁或队列：用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用</p><p>高并发情况。</p></li><li><p>设置过期标志更新缓存：记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存。</p></li><li><p>将缓存失效时间分散开：比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难</p><p>引发集体失效的事件。</p></li></ol><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><strong>问题描述</strong><br>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并</p><p>发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决</p><p>的问题！</p><p>分布式锁主流的实现方案：</p><ol><li>基于数据库实现分布式锁</li><li>基于缓存（Redis等）</li><li>基于Zookeeper</li></ol><p>每一种分布式锁解决方案都有各自的优缺点：</p><ol><li>性能：redis最高</li><li>可靠性：zookeeper最高</li></ol><p><strong>解决方案</strong><br>redis:命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set sku:1:info “OK” NX PX 10000</span><br></pre></td></tr></table></figure><p>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</p><p>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</p><p>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p><p>XX ：只在键已经存在时，才对键进行设置操作。<br><img src="/img/loading.gif" data-original="https://picture-20221025.oss-cn-hangzhou.aliyuncs.com/img/202303131551934.png" alt="image-20230313155110887"></p><ol><li>多个客户端同时获取锁（setnx）</li><li>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</li><li>其他客户端等待重试\</li></ol><p>为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ul><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li><li>加锁和解锁必须具有原子性。</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://www.wweicloud.com">ww</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://www.wweicloud.com/2023/03/13/Redis%E5%9F%BA%E7%A1%80/">https://www.wweicloud.com/2023/03/13/Redis%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.wweicloud.com" target="_blank">青青草原上的菠萝屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/%E9%AB%98%E6%80%A7%E8%83%BD/">高性能</a><a class="post-meta__tags" href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/">高可用</a></div><div class="post_share"><div class="social-share" data-image="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/wallhaven-9doqk8.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/alipay.jpg" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/13/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/" title="Nacos注册中心"><img class="cover" src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/wallhaven-x6zzql.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Nacos注册中心</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/11/private/" title="隐私"><img class="cover" src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/wallhaven-p9ox1m.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">隐私</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/08/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" title="基于Redis实现分布式锁"><img class="cover" src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/kq.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">基于Redis实现分布式锁</div></div></a></div><div><a href="/2023/03/08/Redis%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80id/" title="Redis实现全局唯一id"><img class="cover" src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/wallhaven-zyy77v.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">Redis实现全局唯一id</div></div></a></div><div><a href="/2023/03/08/%E7%BC%93%E5%AD%98/" title="Redis缓存机制"><img class="cover" src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">Redis缓存机制</div></div></a></div><div><a href="/2023/03/08/%E6%8C%81%E4%B9%85%E5%8C%96/" title="Redis持久化"><img class="cover" src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/Snipaste_2023-01-11_21-32-42.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-08</div><div class="title">Redis持久化</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author_top is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/tx.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">ww</div><div class="author-info__description">码一点出路也没有</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/weisyw"><i class="fab fa-github"></i><span>关注</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/weisyw" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2644754894@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a><a class="social-icon" href="/img/qq.jpg" target="_blank"><i class="fab fa-qq"></i></a><a class="social-icon" href="/img/wx.jpg" target="_blank"><i class="fa-brands fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">有问题可以向我提出哦</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86NoSQL"><span class="toc-number">1.</span> <span class="toc-text">认识NoSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFNoSQL"><span class="toc-number">1.1.</span> <span class="toc-text">什么是NoSQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NoSQL%E4%B8%8ESQL%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">1.2.</span> <span class="toc-text">NoSQL与SQL的差异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86Redis"><span class="toc-number">2.</span> <span class="toc-text">认识Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Redis"><span class="toc-number">3.</span> <span class="toc-text">安装Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85Redis%E4%BE%9D%E8%B5%96"><span class="toc-number">3.1.</span> <span class="toc-text">安装Redis依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E5%AE%89%E8%A3%85%E5%8C%85%E5%B9%B6%E8%A7%A3%E5%8E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">上传安装包并解压</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-number">3.3.</span> <span class="toc-text">启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">默认启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">指定配置启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF"><span class="toc-number">3.3.3.</span> <span class="toc-text">开机自启</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">Redis数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">Redis通用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">String类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">Hash类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">List类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.5.</span> <span class="toc-text">Set类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SortedSet%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.6.</span> <span class="toc-text">SortedSet类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmaps%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.7.</span> <span class="toc-text">Bitmaps类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">4.7.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4"><span class="toc-number">4.7.2.</span> <span class="toc-text">命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLogLog%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.8.</span> <span class="toc-text">HyperLogLog类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">4.8.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4-1"><span class="toc-number">4.8.2.</span> <span class="toc-text">命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Geospatial%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.9.</span> <span class="toc-text">Geospatial类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">4.9.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4-2"><span class="toc-number">4.9.2.</span> <span class="toc-text">命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">5.</span> <span class="toc-text">发布和订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">5.1.</span> <span class="toc-text">什么是发布和订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">5.2.</span> <span class="toc-text">Redis的发布和订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.</span> <span class="toc-text">发布订阅命令行实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">6.</span> <span class="toc-text">Redis的Java客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis"><span class="toc-number">6.2.</span> <span class="toc-text">Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Jedis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">6.2.1.</span> <span class="toc-text">Jedis快速入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Jedis%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">6.2.2.</span> <span class="toc-text">Jedis连接池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringDataRedis"><span class="toc-number">6.3.</span> <span class="toc-text">SpringDataRedis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">6.3.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringDataRedis%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">6.3.2.</span> <span class="toc-text">SpringDataRedis序列化方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1-%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">事务_锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">Redis事务定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multi%E3%80%81Exec%E3%80%81Discard"><span class="toc-number">7.2.</span> <span class="toc-text">Multi、Exec、Discard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">事务的错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E6%88%90%E4%BA%8B%E5%8A%A1"><span class="toc-number">7.4.</span> <span class="toc-text">为什么要做成事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-number">7.5.</span> <span class="toc-text">事务冲突问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">7.5.1.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">7.5.2.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">7.5.3.</span> <span class="toc-text">乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WATCH-key-key%E2%80%A6"><span class="toc-number">7.5.4.</span> <span class="toc-text">WATCH key [key…]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unwatch"><span class="toc-number">7.5.5.</span> <span class="toc-text">unwatch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1%E4%B8%89%E7%89%B9%E6%80%A7"><span class="toc-number">7.6.</span> <span class="toc-text">Redis事务三特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">8.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB"><span class="toc-number">8.2.</span> <span class="toc-text">RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%98%E7%BD%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">8.2.1.</span> <span class="toc-text">官网介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RDB-advantages"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">RDB advantages</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RDB-disadvantages"><span class="toc-number">8.2.1.2.</span> <span class="toc-text">RDB disadvantages</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RDB%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">8.2.1.3.</span> <span class="toc-text">RDB的优势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RDB-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">8.2.1.4.</span> <span class="toc-text">RDB 的缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.2.2.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84"><span class="toc-number">8.2.3.</span> <span class="toc-text">备份是如何执行的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fork"><span class="toc-number">8.2.4.</span> <span class="toc-text">Fork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">8.2.5.</span> <span class="toc-text">RDB持久化流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dump-rdb%E6%96%87%E4%BB%B6"><span class="toc-number">8.2.6.</span> <span class="toc-text">dump.rdb文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%BD%8D%E7%BD%AE"><span class="toc-number">8.2.7.</span> <span class="toc-text">配置位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91RDB%E5%BF%AB%E7%85%A7%EF%BC%8C%E4%BF%9D%E6%8C%81%E7%AD%96%E7%95%A5"><span class="toc-number">8.2.8.</span> <span class="toc-text">如何触发RDB快照，保持策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E9%BB%98%E8%AE%A4%E7%9A%84%E5%BF%AB%E7%85%A7%E9%85%8D%E7%BD%AE"><span class="toc-number">8.2.8.1.</span> <span class="toc-text">配置文件中默认的快照配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4save-%E5%92%8C-bgsave"><span class="toc-number">8.2.8.2.</span> <span class="toc-text">命令save 和 bgsave</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#flushall%E5%91%BD%E4%BB%A4"><span class="toc-number">8.2.8.3.</span> <span class="toc-text">flushall命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SNAPSHOTTING%E5%BF%AB%E7%85%A7"><span class="toc-number">8.2.8.4.</span> <span class="toc-text">SNAPSHOTTING快照</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Save"><span class="toc-number">8.2.8.5.</span> <span class="toc-text">Save</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#stop-writes-on-bgsave-error"><span class="toc-number">8.2.8.6.</span> <span class="toc-text">stop-writes-on-bgsave-error</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rdbcompression%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="toc-number">8.2.8.7.</span> <span class="toc-text">rdbcompression压缩文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rdbchecksum%E6%A3%80%E6%9F%A5%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">8.2.8.8.</span> <span class="toc-text">rdbchecksum检查完整性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RDB%E7%9A%84%E5%A4%87%E4%BB%BD"><span class="toc-number">8.2.8.9.</span> <span class="toc-text">RDB的备份</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E4%BC%98%E5%8A%BF"><span class="toc-number">8.2.9.</span> <span class="toc-text">RDB优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E5%8A%A3%E5%8A%BF"><span class="toc-number">8.2.10.</span> <span class="toc-text">RDB劣势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2"><span class="toc-number">8.2.11.</span> <span class="toc-text">如何停止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">8.2.12.</span> <span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF"><span class="toc-number">8.3.</span> <span class="toc-text">AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-1"><span class="toc-number">8.3.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">8.3.2.</span> <span class="toc-text">AOF持久化流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E9%BB%98%E8%AE%A4%E4%B8%8D%E5%BC%80%E5%90%AF"><span class="toc-number">8.3.3.</span> <span class="toc-text">AOF默认不开启</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E5%92%8CRDB%E5%90%8C%E6%97%B6%E5%BC%80%E5%90%AF%EF%BC%8C%E5%90%AC%E8%B0%81%E7%9A%84"><span class="toc-number">8.3.4.</span> <span class="toc-text">AOF和RDB同时开启，听谁的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E5%90%AF%E5%8A%A8-x2F-%E6%81%A2%E5%A4%8D-x2F-%E4%BF%AE%E5%A4%8D"><span class="toc-number">8.3.5.</span> <span class="toc-text">AOF启动&#x2F;恢复&#x2F;修复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E5%90%8C%E6%AD%A5%E9%A2%91%E7%8E%87%E8%AE%BE%E7%BD%AE"><span class="toc-number">8.3.6.</span> <span class="toc-text">AOF同步频率设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rewrite%E5%8E%8B%E7%BC%A9"><span class="toc-number">8.3.7.</span> <span class="toc-text">Rewrite压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-2"><span class="toc-number">8.3.7.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%8E%9F%E7%90%86"><span class="toc-number">8.3.7.2.</span> <span class="toc-text">重写原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-number">8.3.7.3.</span> <span class="toc-text">重写流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E4%BC%98%E5%8A%BF"><span class="toc-number">8.3.8.</span> <span class="toc-text">AOF优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E5%8A%A3%E5%8A%BF"><span class="toc-number">8.3.9.</span> <span class="toc-text">AOF劣势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93-1"><span class="toc-number">8.3.10.</span> <span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">8.4.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E5%93%AA%E4%B8%AA%E5%A5%BD"><span class="toc-number">8.4.1.</span> <span class="toc-text">用哪个好</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E5%BB%BA%E8%AE%AE"><span class="toc-number">8.4.2.</span> <span class="toc-text">官方建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-3"><span class="toc-number">9.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%B9%B2%E5%98%9B"><span class="toc-number">9.2.</span> <span class="toc-text">能干嘛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">9.3.</span> <span class="toc-text">怎么用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%BB%E4%B8%A4%E4%BB%8E"><span class="toc-number">9.4.</span> <span class="toc-text">搭建一主两从</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">9.5.</span> <span class="toc-text">复制原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E4%B8%89%E6%8B%9B"><span class="toc-number">9.6.</span> <span class="toc-text">常见三招</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E4%B8%A4%E4%BB%86"><span class="toc-number">9.6.1.</span> <span class="toc-text">一主两仆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-number">9.6.2.</span> <span class="toc-text">薪火相传</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-number">9.6.3.</span> <span class="toc-text">反客为主</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F-sentinel"><span class="toc-number">9.7.</span> <span class="toc-text">哨兵模式(sentinel)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E4%BB%80%E4%B9%88-4"><span class="toc-number">9.7.1.</span> <span class="toc-text">是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">9.7.2.</span> <span class="toc-text">使用步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%BB%B6%E6%97%B6"><span class="toc-number">9.7.3.</span> <span class="toc-text">复制延时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-number">9.7.4.</span> <span class="toc-text">故障恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">10.</span> <span class="toc-text">集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">10.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E7%BE%A4"><span class="toc-number">10.2.</span> <span class="toc-text">什么是集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4"><span class="toc-number">10.3.</span> <span class="toc-text">搭建集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%9B%86%E7%BE%A4%E4%BF%A1%E6%81%AF"><span class="toc-number">10.4.</span> <span class="toc-text">查看集群信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E8%8A%82%E7%82%B9%E7%9A%84"><span class="toc-number">10.5.</span> <span class="toc-text">Redis如何分配节点的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFslots"><span class="toc-number">10.6.</span> <span class="toc-text">什么是slots</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%9B%86%E7%BE%A4%E4%B8%AD%E5%BD%95%E5%85%A5%E5%80%BC"><span class="toc-number">10.7.</span> <span class="toc-text">在集群中录入值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E5%80%BC"><span class="toc-number">10.8.</span> <span class="toc-text">查询集群中的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D-1"><span class="toc-number">10.9.</span> <span class="toc-text">故障恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84Jedis%E5%BC%80%E5%8F%91"><span class="toc-number">10.10.</span> <span class="toc-text">集群的Jedis开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%8F%90%E4%BE%9B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">10.11.</span> <span class="toc-text">集群提供的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="toc-number">10.12.</span> <span class="toc-text">集群的不足之处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">11.</span> <span class="toc-text">Redis应用问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">11.1.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">11.2.</span> <span class="toc-text">缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">11.3.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">11.4.</span> <span class="toc-text">分布式锁</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%20Sentinel/" title="Sentinel服务保护"><img src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/wallhaven-x6zzql.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Sentinel服务保护"></a><div class="content"><a class="title" href="/2023/03/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4%20Sentinel/" title="Sentinel服务保护">Sentinel服务保护</a><time datetime="2023-03-13T12:22:29.994Z" title="发表于 2023-03-13 20:22:29">2023-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/13/Gateway%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/" title="Gateway服务网关"><img src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/wallhaven-kx8q9m.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Gateway服务网关"></a><div class="content"><a class="title" href="/2023/03/13/Gateway%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/" title="Gateway服务网关">Gateway服务网关</a><time datetime="2023-03-13T10:28:49.748Z" title="发表于 2023-03-13 18:28:49">2023-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/13/Feigen%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/" title="Feign远程调用"><img src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/wallhaven-l8yl6q.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Feign远程调用"></a><div class="content"><a class="title" href="/2023/03/13/Feigen%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/" title="Feign远程调用">Feign远程调用</a><time datetime="2023-03-13T10:22:14.804Z" title="发表于 2023-03-13 18:22:14">2023-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/13/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/" title="Nacos配置中心"><img src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/wallhaven-x6ewo3.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Nacos配置中心"></a><div class="content"><a class="title" href="/2023/03/13/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/" title="Nacos配置中心">Nacos配置中心</a><time datetime="2023-03-13T10:17:31.332Z" title="发表于 2023-03-13 18:17:31">2023-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/13/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" title="Ribbon负载均衡"><img src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/wallhaven-qzry1q.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Ribbon负载均衡"></a><div class="content"><a class="title" href="/2023/03/13/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/" title="Ribbon负载均衡">Ribbon负载均衡</a><time datetime="2023-03-13T10:12:59.193Z" title="发表于 2023-03-13 18:12:59">2023-03-13</time></div></div></div></div></div></div></main><footer id="footer" style="background:#efefef"><div id="footer-wrap"><div class="copyright">&copy;2023 By ww</div><div class="footer_custom_text">鄂ICP备2022011008号</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight,500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><script>(()=>{const o=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo.wweicloud.com/",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.tk-owo-emotion)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&(()=>{const o=document.getElementById("twikoo-count");o&&twikoo.getCommentsCount({envId:"https://twikoo.wweicloud.com/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(t){o.innerText=t[0].count})).catch((function(o){console.error(o)}))})()},t=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js").then(o):setTimeout(o,0)};btf.loadComment(document.getElementById("twikoo-wrap"),t)})()</script></div><script async src="/js/title.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"===location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://www.wweicloud.com/categories/Java/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">😂 Java学习笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.wweicloud.com/categories/MySQL/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎉 MySQL学习笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.wweicloud.com/categories/MyBatis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 MyBatis学习笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.wweicloud.com/categories/MyBatis-Plus/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍔 MyBatis-Plus学习笔记 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.wweicloud.com/categories/Redis/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 Redis学习笔记 (5)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.wweicloud.com/categories/Docker/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍤 Docker学习笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://www.wweicloud.com/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child)}</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(50% - 5px);background:#f2f2f2;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:#b30070}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var a=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock_anzhiyu"),a&&a.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="/img/loading.gif" data-original="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",qweather_key="b16a1fa0e63c46a4b8f28abfb06ae3fe",gaud_map_key="e2b04289e870b005374ee030148d64fd&s=rsv3",baidu_ak_key="undefined",flag=0,clock_rectangle="112.982279,28.19409",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>function butterfly_swiper_injector_config(){var i=document.getElementById("recent-posts");console.log("已挂载butterfly_swiper"),i.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/08/分布式锁/" alt=""><img width="48" height="48" src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/kq.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-08</span><a class="blog-slider__title" href="2023/03/08/分布式锁/" alt="">基于Redis实现分布式锁</a><div class="blog-slider__text">使用Redis实现分布式锁</div><a class="blog-slider__button" href="2023/03/08/分布式锁/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/08/持久化/" alt=""><img width="48" height="48" src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/Snipaste_2023-01-11_21-32-42.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-08</span><a class="blog-slider__title" href="2023/03/08/持久化/" alt="">Redis持久化</a><div class="blog-slider__text">Redis持久化原理，RDB、AOF</div><a class="blog-slider__button" href="2023/03/08/持久化/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/08/缓存/" alt=""><img width="48" height="48" src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/6.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-08</span><a class="blog-slider__title" href="2023/03/08/缓存/" alt="">Redis缓存机制</a><div class="blog-slider__text">Redis缓存机制，缓存击穿、缓存穿透、缓存雪崩等解决方案</div><a class="blog-slider__button" href="2023/03/08/缓存/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/08/MySQL基础/" alt=""><img width="48" height="48" src="/img/loading.gif" data-original="https://blog-ww.oss-cn-hangzhou.aliyuncs.com/2023/03/07/c477e45dc4914f04afe50cb015b724cb.jpg/wallhaven-2yeydm.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-08</span><a class="blog-slider__title" href="2023/03/08/MySQL基础/" alt="">MySQL基础</a><div class="blog-slider__text">MySQL基础知识，包含基本SQL语句、函数、约束、事务、多表联查等</div><a class="blog-slider__button" href="2023/03/08/MySQL基础/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>')}for(var elist="undefined".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_swiper_injector_config()</script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__backInRight"),arr[i].setAttribute("data-wow-duration","700ms"),arr[i].setAttribute("data-wow-delay","700ms"),arr[i].setAttribute("data-wow-offset","100"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__backInLeft"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("pagination"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__fadeInUp"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",(function(){var a=/\.(gif|jpg|jpeg|tiff|png)$/i,e=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach((function(t){var r=t.parentNode;"A"===r.tagName&&(r.href.match(a)||r.href.match(e))&&(r.href=t.dataset.original)}))}))</script><script>!function(t){t.imageLazyLoadSetting.processImages=o;var e=t.imageLazyLoadSetting.isSPA,n=t.imageLazyLoadSetting.preloadRatio||1,a=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function o(){e&&(a=i());for(var o,r=0;r<a.length;r++)0<=(o=(o=a[r]).getBoundingClientRect()).bottom&&0<=o.left&&o.top<=(t.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var e,n,i,o,c=a[r];n=function(){a=a.filter((function(t){return c!==t})),t.imageLazyLoadSetting.onImageLoaded&&t.imageLazyLoadSetting.onImageLoaded(c)},(e=c).hasAttribute("bg-lazy")?(e.removeAttribute("bg-lazy"),n&&n()):(i=new Image,o=e.getAttribute("data-original"),i.onload=function(){e.src=o,e.removeAttribute("data-original"),n&&n()},e.src!==o&&(i.src=o))}()}function r(){clearTimeout(o.tId),o.tId=setTimeout(o,500)}o(),document.addEventListener("scroll",r),t.addEventListener("resize",r),t.addEventListener("orientationchange",r)}(this)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html>